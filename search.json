[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Conference presentations",
    "section": "",
    "text": "ICIAM 2023"
  },
  {
    "objectID": "index.html#presentations",
    "href": "index.html#presentations",
    "title": "Conference presentations",
    "section": "",
    "text": "ICIAM 2023"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#introduction",
    "href": "2023-iciam/2023-iciam-jvkersch.html#introduction",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Introduction",
    "text": "Introduction\nWork done in collaboration with Dong Eui Chang (KAIST, Korea) and Matthew Perlmutter (Universidade Federal de Minas Gerais, Brazil)\n\nPublished as Feedback Integrators for Mechanical Systems with Holonomic Constraints, D. E. Chang, M. Perlmutter, J. Vankerschaver. Sensors 22, no. 17 (2022)."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#ghent-university-global-campus",
    "href": "2023-iciam/2023-iciam-jvkersch.html#ghent-university-global-campus",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Ghent University Global Campus",
    "text": "Ghent University Global Campus\n\nLocated in Incheon, at the heart of the Songdo bio cluster\nCampus of Ghent University (Belgium) focused on life sciences\n15-20 faculty, 40-50 PhD students, 400-500 students"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#what-are-feedback-integrators",
    "href": "2023-iciam/2023-iciam-jvkersch.html#what-are-feedback-integrators",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "What are feedback integrators?",
    "text": "What are feedback integrators?\nIngredients:\n\nDynamical system \\(\\dot{x} = X(x)\\)\nConserved quantity \\(V(x(t)) = 0\\)\n\nProblem: Numerical dynamics will drift away from \\(V^{-1}(0)\\).\nFeedback approach: Make \\(V^{-1}(0)\\) into an attracting invariant manifold (approximately conserved)."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#how-are-feedback-integrators-implemented",
    "href": "2023-iciam/2023-iciam-jvkersch.html#how-are-feedback-integrators-implemented",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "How are feedback integrators implemented?",
    "text": "How are feedback integrators implemented?\n\nAdd restoring force and consider\n\nUnder modest assumptions,\n\n\\(\\nabla V(x)\\) pulls dynamics back to \\(V^{-1}(0)\\)\nDynamics on \\(V^{-1}(0)\\) are not changed\n\nNow, use any standard integrator to numerically integrate the modified vector field."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#example-feedback-equations-for-the-simple-pendulum",
    "href": "2023-iciam/2023-iciam-jvkersch.html#example-feedback-equations-for-the-simple-pendulum",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Example: feedback equations for the simple pendulum",
    "text": "Example: feedback equations for the simple pendulum\n\nConserved quantity: \\[\n    V = \\frac{1}{2} \\Big(H(q, p) - H(q_0, p_0)\\Big)^2\n\\] with \\(H(q, p) = \\frac{1}{2} p^2 - \\cos(q)\\) the Hamiltonian.\nFeedback dynamics:"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#integrating-the-feedback-equations",
    "href": "2023-iciam/2023-iciam-jvkersch.html#integrating-the-feedback-equations",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Integrating the feedback equations",
    "text": "Integrating the feedback equations\n\n\n\n\n\n\n\n\n\nFeedback Euler = forward Euler applied to feedback equations. Comparable behavior to Stormer-Verlet."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#what-about-constrained-dynamics",
    "href": "2023-iciam/2023-iciam-jvkersch.html#what-about-constrained-dynamics",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "What about constrained dynamics?",
    "text": "What about constrained dynamics?\nSuppose that we have \\(2k\\) holonomic constraints \\(f_j(x) = 0\\).\n\nThe Hamiltonian flow \\(X_H\\) will in general not leave the constraint surface invariant.\nDirac showed us how to modify the dynamics so that the constraints are preserved."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#applying-the-feedback-method-to-constrained-dynamics",
    "href": "2023-iciam/2023-iciam-jvkersch.html#applying-the-feedback-method-to-constrained-dynamics",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Applying the feedback method to constrained dynamics",
    "text": "Applying the feedback method to constrained dynamics\n\nThe continuous dynamics leaves the constraints invariant.\nNumerically, the dynamics will drift off the constraint surface.\n\nAdd feedback forces to attract the dynamics back to the constraint surface:"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#example-the-spherical-pendulum",
    "href": "2023-iciam/2023-iciam-jvkersch.html#example-the-spherical-pendulum",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Example: the spherical pendulum",
    "text": "Example: the spherical pendulum\n\n4 conserved quantities to consider:\n\nConstraints: unit length (\\(k_1\\)) and velocity tangent to sphere (\\(k_2\\))\nConservation of energy (\\(k_3\\)) and angular momentum (\\(k_4\\))\n\nJust a big vector fieldâ€¦"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-captures-pendulum-dynamics",
    "href": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-captures-pendulum-dynamics",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Feedback Euler captures pendulum dynamics",
    "text": "Feedback Euler captures pendulum dynamics"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-approximately-preserves-constraints",
    "href": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-approximately-preserves-constraints",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Feedback Euler approximately preserves constraints",
    "text": "Feedback Euler approximately preserves constraints"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-approximately-preserves-energy",
    "href": "2023-iciam/2023-iciam-jvkersch.html#feedback-euler-approximately-preserves-energy",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Feedback Euler approximately preserves energy",
    "text": "Feedback Euler approximately preserves energy"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#feedback-integrators-are-more-efficient-than-constraint-implicit-methods",
    "href": "2023-iciam/2023-iciam-jvkersch.html#feedback-integrators-are-more-efficient-than-constraint-implicit-methods",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Feedback integrators are more efficient than constraint-implicit methods",
    "text": "Feedback integrators are more efficient than constraint-implicit methods\n\n\n\n\n\n\nRATTLE requires solving a constraint equation at each step\nFeedback methods achieve a smaller error given the same computational budget"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#how-to-implement-a-feedback-integrator",
    "href": "2023-iciam/2023-iciam-jvkersch.html#how-to-implement-a-feedback-integrator",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "How to implement a feedback integrator?",
    "text": "How to implement a feedback integrator?\n\nDerive expression for vector field using auto-differentiation\nChoose an appropriate integrator\n\nDone!\nNeed a higher-order method? Just choose a higher-order integrator."
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#section",
    "href": "2023-iciam/2023-iciam-jvkersch.html#section",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 600\n\nfrom shiny import App, reactive, render, ui\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy as sp\nfrom scipy.integrate import solve_ivp\nfrom symbolic import q, p, derived_C, X_full_feedback, to_function\n\n# TODO hardcoded\nq0 = (0, 2**0.5/2, 2**0.5/2)\np0 = (1, -3, 3)\n\n\napp_ui = ui.page_fluid(\n    ui.panel_title(\n        ui.h2(\"Feedback integrator playground\"),\n    ),\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_text(\"H\", \"Hamiltonian\", value=\"(px**2 + py**2 + pz**2)/2\"),\n            ui.input_text(\"C1\", \"Constraint\", value=\"x**2 + y**2 + z**2 - 1\"),\n            ui.input_slider(\"k\", \"Feedback gain\", value=50, min=0, max=100),\n        ),\n        ui.panel_main(\n            ui.navset_tab(\n                ui.nav(\n                    \"Plots\",\n                    ui.output_plot(\"conservation_laws_plot\"),\n                ),\n                ui.nav(\n                    \"Vector fields\",\n                    ui.output_text(\"vector_field\"),\n                ),\n                ui.nav(\n                    \"Solver diagnostics\",\n                    ui.output_text(\"diagnostics\"),   \n                ),\n            ),\n        ),\n    ),\n)\n\n\ndef server(input, output, session):\n\n    @reactive.Calc\n    def run_solver():\n        H = sp.sympify(input.H())\n        C1 = sp.sympify(input.C1())\n        C2 = derived_C(H, input.C1())\n        k = input.k()\n        Xff = to_function(X_full_feedback(H, C1, C2, k, k, k, q0, p0))\n\n        t_eval = np.linspace(0, 10, 100)\n        result = solve_ivp(lambda t, y: Xff(y), [0, 10], q0 + p0, t_eval=t_eval)\n        return result\n\n    @output\n    @render.text\n    def vector_field():\n        H = sp.sympify(input.H())\n        C1 = sp.sympify(input.C1())\n        C2 = derived_C(H, input.C1())\n        k = input.k()\n\n        X = X_full_feedback(H, C1, C2, k, k, k, q0, p0)\n        return f\"{X}\"\n\n    @output\n    @render.plot\n    def conservation_laws_plot():\n        result = run_solver()\n\n        h_fun = sp.lambdify([q + p], input.H())\n        C1_fun = sp.lambdify([q + p], input.C1())\n\n        C2 = derived_C(input.H(), input.C1())\n        C2_fun = sp.lambdify([q + p], C2)\n        h_data = np.array([h_fun(pt) for pt in result.y.T])\n        h_data -= h_data[0]\n\n        c1_data = np.array([C1_fun(pt) for pt in result.y.T])\n        c2_data = np.array([C2_fun(pt) for pt in result.y.T])\n\n        fig, (ax_h, ax_c1, ax_c2) = plt.subplots(ncols=3)\n        ax_h.plot(result.t, h_data)\n        ax_c1.plot(result.t, c1_data)\n        ax_c2.plot(result.t, c2_data)\n\n        return fig\n\n    @output\n    @render.text\n    def diagnostics():\n        return f\"Function evaluations: {run_solver().nfev}\"\n\n\napp = App(app_ui, server)\n\n\n## file: test_symbolic.py\nimport pytest\nimport sympy as sp\n\nfrom symbolic import delta, dot, X_full, derived_C, to_function, eval_at\n\n\ndef test_conservation():\n    H = sp.sympify(\"(px^2 + py^2 + pz^2)/2 + (x^2 + y^2 + z^2)/2\")\n    C1 = sp.sympify(\"x^2 + y^2 + z^2 - 1\")\n    C2 = derived_C(H, C1)\n\n    X = X_full(H, C1, C2)\n\n    assert sp.simplify(dot(X, delta(H))) == 0\n    assert sp.simplify(dot(X, delta(C1))) == 0\n\n    # Checking the conservation of C2 requires using the constraints\n    # themselves. I don't know how to do that, so we fall back on just\n    # substituting a point on the constraint surface and verifying that we get\n    # 0.\n    pt = (0, sp.sqrt(2)/2, sp.sqrt(2)/2, 5, -3, 3)\n    assert eval_at(dot(X, delta(C2)), pt) == pytest.approx(0)\n\n\ndef test_to_fun():\n    H = sp.sympify(\"(px^2 + py^2 + pz^2)/2 + (x^2 + y^2 + z^2)/2\")\n    C1 = sp.sympify(\"x^2 + y^2 + z^2 - 1\")\n    C2 = derived_C(H, C1)\n\n    X = X_full(H, C1, C2)\n    X_fun = to_function(X)\n\n    pt = (0, 2**0.5/2, 2**0.5/2, 5, -3, 3)\n    assert X_fun(pt) == pytest.approx(\n        [5.0, -3.0, 3.0, 0.0, -30.40559, -30.40559])\n\n\n## file: symbolic.py\n\"\"\"Symbolic computations with functions of (q, p).\"\"\"\n\nimport sympy as sp\n\nq = x, y, z = sp.symbols(\"x, y, z\")\np = px, py, pz = sp.symbols(\"px, py, pz\")\n\n\n# Primitives\n\ndef delta_q(f):\n    return [sp.diff(f, v) for v in q]\n\n\ndef delta_p(f):\n    return [sp.diff(f, v) for v in p]\n\n\ndef delta(f):\n    return delta_q(f) + delta_p(f)\n\n\ndef dot(v1, v2):\n    return sum(v*w for (v, w) in zip(v1, v2))\n\n\ndef plus(v1, v2):\n    return [v+w for (v, w) in zip(v1, v2)]\n\n\ndef minus(v1, v2):\n    return [v-w for (v, w) in zip(v1, v2)]\n\n\ndef times_scalar(X, ell):\n    return [v*ell for v in X]\n\n\ndef poisson(f1, f2):\n    return dot(delta_q(f1), delta_p(f2)) - dot(delta_q(f2), delta_p(f1))\n\n\n# Mechanics\n\ndef derived_C(H, C1):\n    C2 = dot(delta_q(C1), delta_p(H))\n    return C2\n\n\ndef X(f):\n    X_q = [poisson(v, f) for v in q]\n    X_p = [poisson(v, f) for v in p]\n    return X_q + X_p\n\n\ndef X_constraint(H, C1, C2):\n    C12 = 1/poisson(C1, C2)\n    H_C1 = poisson(H, C1)\n    H_C2 = poisson(H, C2)\n\n    X_q = [-C12 * (-H_C1 * poisson(v, C2) + H_C2 * poisson(v, C1)) for v in q]\n    X_p = [-C12 * (-H_C1 * poisson(v, C2) + H_C2 * poisson(v, C1)) for v in p]\n    return X_q + X_p\n\n\ndef X_feedback(H, C1, C2, k1, k2, k3, q0, p0):\n    delta_H = H - eval_at(H, q0 + p0)\n    delta_C1 = C1 - eval_at(C1, q0 + p0)\n    delta_C2 = C2 - eval_at(C2, q0 + p0)\n\n    return plus(\n        times_scalar(delta(H), k1*delta_H),\n        plus(\n            times_scalar(delta(C1), k2*delta_C1),\n            times_scalar(delta(C2), k3*delta_C2)))\n\n\ndef X_full(H, C1, C2):\n    X_h = X(H)\n    X_c = X_constraint(H, C1, C2)\n    return plus(X_h, X_c)\n\n\ndef X_full_feedback(H, C1, C2, k1, k2, k3, q0, p0):\n    X_fu = X_full(H, C1, C2)\n    X_fe = X_feedback(H, C1, C2, k1, k2, k3, q0, p0)\n    return minus(X_fu, X_fe)\n\n\n# Utilities\n\ndef to_function(X):\n    callables = [sp.lambdify([q + p], sp.simplify(v)) for v in X]\n\n    def fun(args):\n        return [c(args) for c in callables]\n\n    return fun\n\n\ndef eval_at(expr, args):\n    subs = dict(zip(q + p, args))\n    return expr.evalf(subs=subs)"
  },
  {
    "objectID": "2023-iciam/2023-iciam-jvkersch.html#thank-you",
    "href": "2023-iciam/2023-iciam-jvkersch.html#thank-you",
    "title": "Feedback Integrators for Mechanical Systems with Holonomic Constraints",
    "section": "Thank you",
    "text": "Thank you\nTake-aways from this talk:\n\nFeedback integrators sacrifice accuracy for versatility\nFeedback integrators can be implemented in a straightforward way\n\nFuture work:\n\nApply feedback integrators in situations where near-preservation is good enough (e.g.Â neural networks with Stiefel weights)"
  }
]